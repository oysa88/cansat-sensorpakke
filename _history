{"entries":[{"timestamp":1769943127246,"editorVersion":"8.0.18","changes":[{"type":"edited","filename":"main.ts","patch":[{"start1":0,"length1":46,"diffs":[[1,"\n"]]}]},{"type":"edited","filename":"pxt.json","patch":[{"start1":124,"length1":51,"diffs":[[1,"        \"microphone\": \"*\"\n"]]},{"start1":172,"length1":0,"diffs":[[1,"        \"main.blocks\",\n"]]},{"start1":214,"length1":195,"diffs":[[1,"        \"README.md\"\n"]]},{"start1":241,"length1":31,"diffs":[[1,"    \"additionalFilePaths\": []\n"]]}]},{"type":"removed","filename":"main.blocks","value":"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <block type=\"pxt-on-start\"></block>\n  <block type=\"device_forever\"></block>\n</xml>"},{"type":"added","filename":"gy91.ts","value":"//% color=#FF4E2B weight=35 icon=\"\\uf14e\" block=\"GY91 - 9DOF\"\nnamespace GY91 {\n\n    const MPU = 0x68\n    const BMP280 = 0x76\n    const AK8963 = 0x0C   // Inne i MPU9250\n    const HMC5883 = 0x1E\n    const QMC5883 = 0x0D\n\n    const ACCEL_SCALE = 16384\n    const GYRO_SCALE = 131\n    const MAG_AK_SCALE = 0.15\n    const MAG_HMC_SCALE = 0.92\n    const MAG_QMC_SCALE = 0.083\n\n    let gyroOffsetX = 0\n    let gyroOffsetY = 0\n    let gyroOffsetZ = 0\n    let yaw = 0\n    let lastTime = 0\n    let magType = 0 // 0=none, 1=AK8963, 2=HMC, 3=QMC\n\n    // BMP280 kalibrering\n    let dig_T1 = 0, dig_T2 = 0, dig_T3 = 0\n    let dig_P1 = 0, dig_P2 = 0, dig_P3 = 0\n    let dig_P4 = 0, dig_P5 = 0, dig_P6 = 0\n    let dig_P7 = 0, dig_P8 = 0, dig_P9 = 0\n    let tFine = 0\n\n    export enum Axis { X, Y, Z }\n    export enum Tilt { Pitch, Roll }\n\n    function round2(v: number): number {\n        return Math.round(v * 100) / 100\n    }\n\n    // ------------------ INIT ------------------\n    //% block=\"initialiser GY91\"\n    //% group=\"Oppsett\"\n    export function init(): void {\n        write8(MPU, 0x6B, 0x00) // wake MPU\n        write8(MPU, 0x1B, 0x00) // gyro full scale\n        write8(MPU, 0x1C, 0x00) // accel full scale\n\n        write8(BMP280, 0xF4, 0x27) // normal mode\n        write8(BMP280, 0xF5, 0xA0) // config\n\n        readCalibration()\n        detectMagnetometer()\n        lastTime = input.runningTime()\n    }\n\n    // ------------------ SENSORER ------------------\n    //% block=\"akselerasjon %axis (g)\"\n    //% group=\"Akselerometer\"\n    export function acceleration(axis: Axis): number {\n        let raw = axis == Axis.X ? read16(MPU, 0x3B)\n            : axis == Axis.Y ? read16(MPU, 0x3D)\n                : read16(MPU, 0x3F)\n        return round2(raw / ACCEL_SCALE)\n    }\n\n    //% block=\"rotasjonshastighet %axis (°/s)\"\n    //% group=\"Gyroskop\"\n    export function gyro(axis: Axis): number {\n        let raw = axis == Axis.X ? read16(MPU, 0x43) - gyroOffsetX\n            : axis == Axis.Y ? read16(MPU, 0x45) - gyroOffsetY\n                : read16(MPU, 0x47) - gyroOffsetZ\n        return round2(raw / GYRO_SCALE)\n    }\n\n    //% block=\"magnetfelt %axis (µT)\"\n    //% group=\"Magnetometer\"\n    export function magneticField(axis: Axis): number {\n        if (magType == 1) {\n            let reg = axis == Axis.X ? 0x03 : axis == Axis.Y ? 0x05 : 0x07\n            return round2(magRawAK(reg) * MAG_AK_SCALE)\n        }\n        if (magType == 2) {\n            let reg = axis == Axis.X ? 0x03 : axis == Axis.Y ? 0x07 : 0x05\n            return round2(magRawHMC(reg) * MAG_HMC_SCALE)\n        }\n        if (magType == 3) {\n            let x = read16(QMC5883, 0x00)\n            let y = read16(QMC5883, 0x02)\n            let z = read16(QMC5883, 0x04)\n            let v = axis == Axis.X ? x : axis == Axis.Y ? y : z\n            return round2(v * MAG_QMC_SCALE)\n        }\n        return 0\n    }\n\n    //% block=\"kompassretning (grader)\"\n    //% group=\"Magnetometer\"\n    export function heading(): number {\n        let angle = Math.atan2(magneticField(Axis.Y), magneticField(Axis.X)) * 180 / Math.PI\n        if (angle < 0) angle += 360\n        return round2(angle)\n    }\n\n    //% block=\"magnetometer type\"\n    //% group=\"Oppsett\"\n    export function magnetometerType(): string {\n        if (magType == 1) return \"AK8963 (MPU9250)\"\n        if (magType == 2) return \"HMC5883L\"\n        if (magType == 3) return \"QMC5883L (klone)\"\n        return \"Ikke funnet\"\n    }\n\n    //% block=\"helning %t (grader)\"\n    //% group=\"Orientering\"\n    export function tilt(t: Tilt): number {\n        let ax = acceleration(Axis.X)\n        let ay = acceleration(Axis.Y)\n        let az = acceleration(Axis.Z)\n\n        if (t == Tilt.Pitch)\n            return round2(Math.atan2(-ax, Math.sqrt(ay * ay + az * az)) * 180 / Math.PI)\n        else\n            return round2(Math.atan2(ay, az) * 180 / Math.PI)\n    }\n\n    //% block=\"rotasjonsvinkel rundt Z (yaw)\"\n    //% group=\"Rotasjon\"\n    export function yawAngle(): number {\n        let now = input.runningTime()\n        let dt = (now - lastTime) / 1000\n        lastTime = now\n        yaw += gyro(Axis.Z) * dt\n        return round2(yaw)\n    }\n\n    //% block=\"temperatur (°C)\"\n    //% group=\"Miljø\"\n    export function temperature(): number {\n        let adc_T = read24(BMP280, 0xFA) >> 4\n        let var1 = (((adc_T >> 3) - (dig_T1 << 1)) * dig_T2) >> 11\n        let var2 = (((((adc_T >> 4) - dig_T1) * ((adc_T >> 4) - dig_T1)) >> 12) * dig_T3) >> 14\n        tFine = var1 + var2\n        return round2(((tFine * 5 + 128) >> 8) / 100)\n    }\n\n    //% block=\"lufttrykk (Pa)\"\n    //% group=\"Miljø\"\n    export function pressure(): number {\n        temperature()\n        let adc_P = read24(BMP280, 0xF7) >> 4\n        let var1 = tFine - 128000\n        let var2 = var1 * var1 * dig_P6\n        var2 = var2 + ((var1 * dig_P5) << 17)\n        var2 = var2 + (dig_P4 << 35)\n        var1 = ((var1 * var1 * dig_P3) >> 8) + ((var1 * dig_P2) << 12)\n        var1 = (((1 << 47) + var1) * dig_P1) >> 33\n        if (var1 == 0) return 0\n        let p = 1048576 - adc_P\n        p = (((p << 31) - var2) * 3125) / var1\n        var1 = (dig_P9 * (p >> 13) * (p >> 13)) >> 25\n        var2 = (dig_P8 * p) >> 19\n        p = ((p + var1 + var2) >> 8) + (dig_P7 << 4)\n        return round2(p / 256)\n    }\n\n    // ------------------ MAGNETOMETER DETECTION ------------------\n    function detectMagnetometer() {\n        // slå på bypass kun midlertidig\n        write8(MPU, 0x37, 0x02)\n        control.waitMicros(10000)\n\n        // AK8963\n        pins.i2cWriteNumber(AK8963, 0x00, NumberFormat.UInt8BE, true)\n        let id = pins.i2cReadNumber(AK8963, NumberFormat.UInt8BE, true)\n        if (id == 0x48) { write8(AK8963, 0x0A, 0x16); magType = 1; write8(MPU, 0x37, 0x00); return }\n\n        // HMC5883\n        pins.i2cWriteNumber(HMC5883, 0x0A, NumberFormat.UInt8BE, true)\n        id = pins.i2cReadNumber(HMC5883, NumberFormat.UInt8BE, true)\n        if (id == 0x48) { write8(HMC5883, 0x00, 0x70); write8(HMC5883, 0x01, 0x20); write8(HMC5883, 0x02, 0x00); magType = 2; write8(MPU, 0x37, 0x00); return }\n\n        // QMC5883\n        pins.i2cWriteNumber(QMC5883, 0x0D, NumberFormat.UInt8BE, true)\n        id = pins.i2cReadNumber(QMC5883, NumberFormat.UInt8BE, true)\n        if (id == 0xFF || id == 0x01) { write8(QMC5883, 0x0B, 0x01); write8(QMC5883, 0x09, 0x1D); magType = 3; write8(MPU, 0x37, 0x00); return }\n\n        magType = 0\n        write8(MPU, 0x37, 0x00)\n    }\n\n    function magRawAK(reg: number): number {\n        pins.i2cWriteNumber(AK8963, reg, NumberFormat.UInt8BE)\n        let lo = pins.i2cReadNumber(AK8963, NumberFormat.UInt8BE)\n        let hi = pins.i2cReadNumber(AK8963, NumberFormat.UInt8BE)\n        let v = (hi << 8) | lo\n        return v > 32767 ? v - 65536 : v\n    }\n\n    function magRawHMC(reg: number): number {\n        return read16(HMC5883, reg)\n    }\n\n    // ------------------ I2C-HJELPEFUNKSJONER ------------------\n    function write8(addr: number, reg: number, val: number): void {\n        pins.i2cWriteBuffer(addr, Buffer.fromArray([reg, val]))\n    }\n\n    function read16(addr: number, reg: number): number {\n        pins.i2cWriteNumber(addr, reg, NumberFormat.UInt8BE)\n        let hi = pins.i2cReadNumber(addr, NumberFormat.UInt8BE)\n        let lo = pins.i2cReadNumber(addr, NumberFormat.UInt8BE)\n        let v = (hi << 8) | lo\n        return v > 32767 ? v - 65536 : v\n    }\n\n    function read24(addr: number, reg: number): number {\n        pins.i2cWriteNumber(addr, reg, NumberFormat.UInt8BE)\n        let msb = pins.i2cReadNumber(addr, NumberFormat.UInt8BE)\n        let lsb = pins.i2cReadNumber(addr, NumberFormat.UInt8BE)\n        let xlsb = pins.i2cReadNumber(addr, NumberFormat.UInt8BE)\n        return (msb << 16) | (lsb << 8) | xlsb\n    }\n\n    function readCalibration() {\n        dig_T1 = read16(BMP280, 0x88)\n        dig_T2 = read16(BMP280, 0x8A)\n        dig_T3 = read16(BMP280, 0x8C)\n        dig_P1 = read16(BMP280, 0x8E)\n        dig_P2 = read16(BMP280, 0x90)\n        dig_P3 = read16(BMP280, 0x92)\n        dig_P4 = read16(BMP280, 0x94)\n        dig_P5 = read16(BMP280, 0x96)\n        dig_P6 = read16(BMP280, 0x98)\n        dig_P7 = read16(BMP280, 0x9A)\n        dig_P8 = read16(BMP280, 0x9C)\n        dig_P9 = read16(BMP280, 0x9E)\n    }\n\n    // ------------------ I2C-SCANNER ------------------\n    //% block=\"skann I2C-bus\"\n    //% group=\"Oppsett\"\n    export function scanI2C(): number[] {\n        let found: number[] = []\n        for (let addr = 0x03; addr <= 0x77; addr++) {\n            let ok = true\n            control.inBackground(() => {\n                try {\n                    pins.i2cWriteNumber(addr, 0x00, NumberFormat.UInt8BE, true)\n                } catch {\n                    ok = false\n                }\n            })\n            if (ok) found.push(addr)\n        }\n        return found\n    }\n}"},{"type":"added","filename":"neo-6m.ts","value":"// Skriv inn koden din her\n"},{"type":"added","filename":"bme280.ts","value":"enum BME280_I2C_ADDRESS {\n    //% block=\"0x76\"\n    ADDR_0x76 = 0x76,\n    //% block=\"0x77\"\n    ADDR_0x77 = 0x77\n}\n\nenum BME280_T {\n    //% block=\"C\"\n    T_C = 0,\n    //% block=\"F\"\n    T_F = 1\n}\n\nenum BME280_P {\n    //% block=\"Pa\"\n    Pa = 0,\n    //% block=\"hPa\"\n    hPa = 1\n}\n\n/**\n * BME280 block\n */\n//% weight=40 color=#70c0f0 icon=\"\\uf2c9\" block=\"BME280\"\n//% groups=[\"Målinger\", \"Hendelser\", \"Oppsett\"]\nnamespace BME280 {\n    let BME280_I2C_ADDR = BME280_I2C_ADDRESS.ADDR_0x76\n\n    function setreg(reg: number, dat: number): void {\n        let buf = pins.createBuffer(2);\n        buf[0] = reg;\n        buf[1] = dat;\n        pins.i2cWriteBuffer(BME280_I2C_ADDR, buf);\n    }\n\n    function getreg(reg: number): number {\n        pins.i2cWriteNumber(BME280_I2C_ADDR, reg, NumberFormat.UInt8BE);\n        return pins.i2cReadNumber(BME280_I2C_ADDR, NumberFormat.UInt8BE);\n    }\n\n    function getInt8LE(reg: number): number {\n        pins.i2cWriteNumber(BME280_I2C_ADDR, reg, NumberFormat.UInt8BE);\n        return pins.i2cReadNumber(BME280_I2C_ADDR, NumberFormat.Int8LE);\n    }\n\n    function getUInt16LE(reg: number): number {\n        pins.i2cWriteNumber(BME280_I2C_ADDR, reg, NumberFormat.UInt8BE);\n        return pins.i2cReadNumber(BME280_I2C_ADDR, NumberFormat.UInt16LE);\n    }\n\n    function getInt16LE(reg: number): number {\n        pins.i2cWriteNumber(BME280_I2C_ADDR, reg, NumberFormat.UInt8BE);\n        return pins.i2cReadNumber(BME280_I2C_ADDR, NumberFormat.Int16LE);\n    }\n\n    let dig_T1 = getUInt16LE(0x88)\n    let dig_T2 = getInt16LE(0x8A)\n    let dig_T3 = getInt16LE(0x8C)\n    let dig_P1 = getUInt16LE(0x8E)\n    let dig_P2 = getInt16LE(0x90)\n    let dig_P3 = getInt16LE(0x92)\n    let dig_P4 = getInt16LE(0x94)\n    let dig_P5 = getInt16LE(0x96)\n    let dig_P6 = getInt16LE(0x98)\n    let dig_P7 = getInt16LE(0x9A)\n    let dig_P8 = getInt16LE(0x9C)\n    let dig_P9 = getInt16LE(0x9E)\n    let dig_H1 = getreg(0xA1)\n    let dig_H2 = getInt16LE(0xE1)\n    let dig_H3 = getreg(0xE3)\n    let a = getreg(0xE5)\n    let dig_H4 = (getreg(0xE4) << 4) + (a % 16)\n    let dig_H5 = (getreg(0xE6) << 4) + (a >> 4)\n    let dig_H6 = getInt8LE(0xE7)\n    setreg(0xF2, 0x04)\n    setreg(0xF4, 0x2F)\n    setreg(0xF5, 0x0C)\n    let T = 0\n    let P = 0\n    let H = 0\n\n    function get(): void {\n        let adc_T = (getreg(0xFA) << 12) + (getreg(0xFB) << 4) + (getreg(0xFC) >> 4)\n        let var1 = (((adc_T >> 3) - (dig_T1 << 1)) * dig_T2) >> 11\n        let var2 = (((((adc_T >> 4) - dig_T1) * ((adc_T >> 4) - dig_T1)) >> 12) * dig_T3) >> 14\n        let t = var1 + var2\n        T = Math.idiv((t * 5 + 128) >> 8, 100)\n        var1 = (t >> 1) - 64000\n        var2 = (((var1 >> 2) * (var1 >> 2)) >> 11) * dig_P6\n        var2 = var2 + ((var1 * dig_P5) << 1)\n        var2 = (var2 >> 2) + (dig_P4 << 16)\n        var1 = (((dig_P3 * ((var1 >> 2) * (var1 >> 2)) >> 13) >> 3) + (((dig_P2) * var1) >> 1)) >> 18\n        var1 = ((32768 + var1) * dig_P1) >> 15\n        if (var1 == 0)\n            return; // avoid exception caused by division by zero\n        let adc_P = (getreg(0xF7) << 12) + (getreg(0xF8) << 4) + (getreg(0xF9) >> 4)\n        let _p = ((1048576 - adc_P) - (var2 >> 12)) * 3125\n        _p = Math.idiv(_p, var1) * 2;\n        var1 = (dig_P9 * (((_p >> 3) * (_p >> 3)) >> 13)) >> 12\n        var2 = (((_p >> 2)) * dig_P8) >> 13\n        P = _p + ((var1 + var2 + dig_P7) >> 4)\n        let adc_H = (getreg(0xFD) << 8) + getreg(0xFE)\n        var1 = t - 76800\n        var2 = (((adc_H << 14) - (dig_H4 << 20) - (dig_H5 * var1)) + 16384) >> 15\n        var1 = var2 * (((((((var1 * dig_H6) >> 10) * (((var1 * dig_H3) >> 11) + 32768)) >> 10) + 2097152) * dig_H2 + 8192) >> 14)\n        var2 = var1 - (((((var1 >> 15) * (var1 >> 15)) >> 7) * dig_H1) >> 4)\n        if (var2 < 0) var2 = 0\n        if (var2 > 419430400) var2 = 419430400\n        H = (var2 >> 12) >> 10\n    }\n\n    /**\n     * get pressure\n     */\n    //% blockId=\"BME280_GET_PRESSURE\" block=\"Trykk %u\"\n    //% group=\"Målinger\"\n    //% weight=79 blockGap=8\n    export function pressure(u: BME280_P): number {\n        get();\n        if (u == BME280_P.Pa) return P;\n        else return Math.idiv(P, 100)\n    }\n\n    /**\n     * get temperature\n     */\n    //% blockId=\"BME280_GET_TEMPERATURE\" block=\"Temperatur %u\"\n    //% group=\"Målinger\"\n    //% weight=80 blockGap=8\n    export function temperature(u: BME280_T): number {\n        get();\n        if (u == BME280_T.T_C) return T;\n        else return 32 + Math.idiv(T * 9, 5)\n    }\n\n    /**\n     * get humidity\n     */\n    //% blockId=\"BME280_GET_HUMIDITY\" block=\"Luftfuktighet\"\n    //% group=\"Målinger\"\n    //% weight=78 blockGap=8\n    export function humidity(): number {\n        get();\n        return H;\n    }\n\n    /**\n     * power on\n     */\n    //% blockId=\"BME280_POWER_ON\" block=\"Skru PÅ\"\n    //% group=\"Oppsett\"\n    //% weight=22 blockGap=8\n    export function PowerOn() {\n        setreg(0xF4, 0x2F)\n    }\n\n    /**\n     * power off\n     */\n    //% blockId=\"BME280_POWER_OFF\" block=\"Skru AV\"\n    //% group=\"Oppsett\"\n    //% weight=21 blockGap=8\n    export function PowerOff() {\n        setreg(0xF4, 0)\n    }\n\n    /**\n     * Calculate Dewpoint\n     */\n    //% block=\"Duggpunkt\"\n    //% group=\"Målinger\"\n    //% weight=76 blockGap=8\n    export function Dewpoint(): number {\n        get();\n        return T - Math.idiv(100 - H, 5)\n    }\n\n    /**\n     * Pressure below Event\n     */\n    //% block=\"Trykk lavere enn %dat\" dat.defl=100000\n    //% group=\"Hendelser\"\n    export function PressureBelowThan(dat: number, body: () => void): void {\n        control.inBackground(function () {\n            while (true) {\n                get()\n                if (P < dat) {\n                    body()\n                }\n                basic.pause(1000)\n            }\n        })\n    }\n\n    /**\n     * Pressure higher Event\n     */\n    //% block=\"Trykk høyere enn %dat\" dat.defl=100000\n    //% group=\"Hendelser\"\n    export function PressureHigherThan(dat: number, body: () => void): void {\n        control.inBackground(function () {\n            while (true) {\n                get()\n                if (P > dat) {\n                    body()\n                }\n                basic.pause(1000)\n            }\n        })\n    }\n\n    /**\n     * humidity below Event\n     */\n    //% block=\"Luftfuktighet lavere enn %dat\" dat.defl=10\n    //% group=\"Hendelser\"\n    export function HumidityBelowThan(dat: number, body: () => void): void {\n        control.inBackground(function () {\n            while (true) {\n                get()\n                if (H < dat) {\n                    body()\n                }\n                basic.pause(1000)\n            }\n        })\n    }\n\n    /**\n     * humidity higher Event\n     */\n    //% block=\"Luftfuktighet høyere enn %dat\" dat.defl=50\n    //% group=\"Hendelser\"\n    export function HumidityHigherThan(dat: number, body: () => void): void {\n        control.inBackground(function () {\n            while (true) {\n                get()\n                if (H > dat) {\n                    body()\n                }\n                basic.pause(1000)\n            }\n        })\n    }\n\n    /**\n     * temperature below Event\n     */\n    //% block=\"Temperatur lavere enn %dat\" dat.defl=10\n    //% group=\"Hendelser\"\n    export function TemperatureBelowThan(dat: number, body: () => void): void {\n        control.inBackground(function () {\n            while (true) {\n                get()\n                if (T < dat) {\n                    body()\n                }\n                basic.pause(1000)\n            }\n        })\n    }\n\n    /**\n     * temperature higher Event\n     */\n    //% block=\"Temperatur høyere enn %dat\" dat.defl=30\n    //% group=\"Hendelser\"\n    export function TemperatureHigherThan(dat: number, body: () => void): void {\n        control.inBackground(function () {\n            while (true) {\n                get()\n                if (T > dat) {\n                    body()\n                }\n                basic.pause(1000)\n            }\n        })\n    }\n\n    /**\n     * set I2C address\n     */\n    //% blockId=\"BME280_SET_ADDRESS\" block=\"Sett adresse %addr\"\n    //% group=\"Oppsett\"\n    //% weight=20 blockGap=8\n    export function Address(addr: BME280_I2C_ADDRESS) {\n        BME280_I2C_ADDR = addr\n    }\n}"},{"type":"added","filename":"e32-radio.ts","value":"// Skriv inn koden din her\n"},{"type":"added","filename":"sgp30.ts","value":"// Skriv inn koden din her\n"},{"type":"added","filename":"datalogger.ts","value":"/**\n * Lagre data til flash-minne\n */\n//% block=\"Datalogger\"\n//% icon=\"\\uf0ce\"\n//% color=\"#378273\"\nnamespace datalogger {\n    export enum DeleteType {\n        //% block=\"raskt\"\n        Fast,\n        //% block=\"fullstendig\"\n        Full\n    }\n\n    let onLogFullHandler: () => void;\n    let _disabled = false;\n\n    let initialized = false;\n    function init() {\n        if (initialized)\n            return;\n        initialized = true;\n\n        includeTimestamp(FlashLogTimeStampFormat.Seconds);\n        mirrorToSerial(false);\n\n        control.onEvent(DAL.MICROBIT_ID_LOG, DAL.MICROBIT_LOG_EVT_LOG_FULL, () => {\n            _disabled = true;\n            if (onLogFullHandler) {\n                onLogFullHandler();\n            } else {\n                basic.showLeds(`\n                    # . . . #\n                    # # . # #\n                    . . . . .\n                    . # # # .\n                    # . . . #\n                `);\n                basic.pause(1000);\n                basic.clearScreen();\n                basic.showString(\"928\");\n            }\n        });\n    }\n\n\n    export class ColumnValue {\n        public value: string;\n        constructor(\n            public column: string,\n            value: any\n        ) {\n            this.value = \"\" + value;\n        }\n    }\n\n    /**\n     * A column and value to log to flash storage\n     * @param column the column to set\n     * @param value the value to set.\n     * @returns A new value that can be stored in flash storage using log data\n     */\n    //% block=\"kolonne $column verdi $value\"\n    //% value.shadow=math_number\n    //% column.shadow=datalogger_columnfield\n    //% blockId=dataloggercreatecolumnvalue\n    //% group=\"micro:bit (V2)\"\n    //% weight=80 help=datalogger/create-cv\n    export function createCV(column: string, value: any): ColumnValue {\n        return new ColumnValue(column, value);\n    }\n\n    //% block=\"$column\"\n    //% blockId=datalogger_columnfield\n    //% group=\"micro:bit (V2)\"\n    //% blockHidden=true shim=TD_ID\n    //% column.fieldEditor=\"autocomplete\" column.fieldOptions.decompileLiterals=true\n    //% column.fieldOptions.key=\"dataloggercolumn\"\n    export function _columnField(column: string) {\n        return column\n    }\n\n    /**\n     * Log data to flash storage\n     * @param data Array of data to be logged to flash storage\n     */\n    //% block=\"lagre data array $data\"\n    //% blockId=dataloggerlogdata\n    //% data.shadow=lists_create_with\n    //% data.defl=dataloggercreatecolumnvalue\n    //% group=\"micro:bit (V2)\"\n    //% blockHidden=true\n    //% weight=100\n    export function logData(data: ColumnValue[]): void {\n        if (!data || !data.length)\n            return;\n        init();\n\n        if (_disabled)\n            return;\n\n        flashlog.beginRow();\n        for (const cv of data) {\n            flashlog.logData(cv.column, cv.value);\n        }\n        flashlog.endRow();\n    }\n\n    /**\n     * Log data to flash storage\n     * @param data1 First column and value to be logged\n     * @param data2 [optional] second column and value to be logged\n     * @param data3 [optional] third column and value to be logged\n     * @param data4 [optional] fourth column and value to be logged\n     * @param data5 [optional] fifth column and value to be logged\n     * @param data6 [optional] sixth column and value to be logged\n     * @param data7 [optional] seventh column and value to be logged\n     * @param data8 [optional] eighth column and value to be logged\n     * @param data9 [optional] ninth column and value to be logged\n     * @param data10 [optional] tenth column and value to be logged\n     * @param data11 [optional] elleventh column and value to be logged\n     * @param data12 [optional] twelveth column and value to be logged\n     * @param data13 [optional] thirtenth column and value to be logged\n     * @param data14 [optional] fourtenth column and value to be logged\n     * @param data15 [optional] fifthtenth column and value to be logged\n     * @param data16 [optional] sixtenth column and value to be logged\n     * @param data17 [optional] seventeth column and value to be logged\n     * @param data18 [optional] eightenth column and value to be logged\n     * @param data19 [optional] ninetenth column and value to be logged\n     * @param data20 [optional] twentieth column and value to be logged\n     */\n    //% block=\"logg data $data1||$data2 $data3 $data4 $data5 $data6 $data7 $data8 $data9 $data10 $data11 $data12 $data13 $data14 $data15 $data16 $data17 $data18 $data19 $data20\"\n    //% blockId=dataloggerlog\n    //% data1.shadow=dataloggercreatecolumnvalue\n    //% data2.shadow=dataloggercreatecolumnvalue\n    //% data3.shadow=dataloggercreatecolumnvalue\n    //% data4.shadow=dataloggercreatecolumnvalue\n    //% data5.shadow=dataloggercreatecolumnvalue\n    //% data6.shadow=dataloggercreatecolumnvalue\n    //% data7.shadow=dataloggercreatecolumnvalue\n    //% data8.shadow=dataloggercreatecolumnvalue\n    //% data9.shadow=dataloggercreatecolumnvalue\n    //% data10.shadow=dataloggercreatecolumnvalue\n    //% data11.shadow=dataloggercreatecolumnvalue\n    //% data12.shadow=dataloggercreatecolumnvalue\n    //% data13.shadow=dataloggercreatecolumnvalue\n    //% data14.shadow=dataloggercreatecolumnvalue\n    //% data15.shadow=dataloggercreatecolumnvalue\n    //% data16.shadow=dataloggercreatecolumnvalue\n    //% data17.shadow=dataloggercreatecolumnvalue\n    //% data18.shadow=dataloggercreatecolumnvalue\n    //% data19.shadow=dataloggercreatecolumnvalue\n    //% data20.shadow=dataloggercreatecolumnvalue\n    //% inlineInputMode=\"variable\"\n    //% inlineInputModeLimit=1\n    //% group=\"micro:bit (V2)\"\n    //% weight=100 help=datalogger/log\n    export function log(\n        data1: datalogger.ColumnValue,\n        data2?: datalogger.ColumnValue,\n        data3?: datalogger.ColumnValue,\n        data4?: datalogger.ColumnValue,\n        data5?: datalogger.ColumnValue,\n        data6?: datalogger.ColumnValue,\n        data7?: datalogger.ColumnValue,\n        data8?: datalogger.ColumnValue,\n        data9?: datalogger.ColumnValue,\n        data10?: datalogger.ColumnValue,\n        data11?: datalogger.ColumnValue,\n        data12?: datalogger.ColumnValue,\n        data13?: datalogger.ColumnValue,\n        data14?: datalogger.ColumnValue,\n        data15?: datalogger.ColumnValue,\n        data16?: datalogger.ColumnValue,\n        data17?: datalogger.ColumnValue,\n        data18?: datalogger.ColumnValue,\n        data19?: datalogger.ColumnValue,\n        data20?: datalogger.ColumnValue\n    ): void {\n        logData(\n            [\n                data1,\n                data2,\n                data3,\n                data4,\n                data5,\n                data6,\n                data7,\n                data8,\n                data9,\n                data10,\n                data11,\n                data12,\n                data13,\n                data14,\n                data15,\n                data16,\n                data17,\n                data18,\n                data19,\n                data20,\n            ].filter(el => !!el)\n        );\n    }\n\n    /**\n     * Set the columns for future data logging\n     * @param cols Array of the columns that will be logged.\n     */\n    //% block=\"sett kolonne $cols\"\n    //% blockId=dataloggersetcolumns\n    //% data.shadow=list_create_with\n    //% data.defl=datalogger_columnfield\n    //% group=\"micro:bit (V2)\"\n    //% blockHidden=true\n    //% weight=70\n    export function setColumns(cols: string[]): void {\n        if (!cols)\n            return;\n\n        logData(cols.map(col => createCV(col, \"\")));\n    }\n\n    /**\n     * Set the columns for future data logging\n     * @param col1 Title for first column to be added\n     * @param col2 Title for second column to be added\n     * @param col3 Title for third column to be added\n     * @param col4 Title for fourth column to be added\n     * @param col5 Title for fifth column to be added\n     * @param col6 Title for sixth column to be added\n     * @param col7 Title for seventh column to be added\n     * @param col8 Title for eighth column to be added\n     * @param col9 Title for ninth column to be added\n     * @param col10 Title for tenth column to be added\n     * @param col11 Title for elleventh column to be added\n     * @param col12 Title for twelveth column to be added\n     * @param col13 Title for thirtenth column to be added\n     * @param col14 Title for fourtenth column to be added\n     * @param col15 Title for fifthtenth column to be added\n     * @param col16 Title for sixtenth column to be added\n     * @param col17 Title for sevententh column to be added\n     * @param col18 Title for eighttenth column to be added\n     * @param col19 Title for ninetenth column to be added\n     * @param col20 Title for twentieth column to be added\n     */\n    //% block=\"sett kolonner $col1||$col2 $col3 $col4 $col5 $col6 $col7 $col8 $col9 $col10 $col11 $col12 $col13 $col14 $col15 $col16 $col17 $col18 $col19 $col20\"\n    //% blockId=dataloggersetcolumntitles\n    //% inlineInputMode=\"variable\"\n    //% inlineInputModeLimit=1\n    //% group=\"micro:bit (V2)\"\n    //% weight=70 help=datalogger/set-column-titles\n    //% col1.shadow=datalogger_columnfield\n    //% col2.shadow=datalogger_columnfield\n    //% col3.shadow=datalogger_columnfield\n    //% col4.shadow=datalogger_columnfield\n    //% col5.shadow=datalogger_columnfield\n    //% col6.shadow=datalogger_columnfield\n    //% col7.shadow=datalogger_columnfield\n    //% col8.shadow=datalogger_columnfield\n    //% col9.shadow=datalogger_columnfield\n    //% col10.shadow=datalogger_columnfield\n    //% col11.shadow=datalogger_columnfield\n    //% col12.shadow=datalogger_columnfield\n    //% col13.shadow=datalogger_columnfield\n    //% col14.shadow=datalogger_columnfield\n    //% col15.shadow=datalogger_columnfield\n    //% col16.shadow=datalogger_columnfield\n    //% col17.shadow=datalogger_columnfield\n    //% col18.shadow=datalogger_columnfield\n    //% col19.shadow=datalogger_columnfield\n    //% col20.shadow=datalogger_columnfield\n    export function setColumnTitles(\n        col1: string,\n        col2?: string,\n        col3?: string,\n        col4?: string,\n        col5?: string,\n        col6?: string,\n        col7?: string,\n        col8?: string,\n        col9?: string,\n        col10?: string,\n        col11?: string,\n        col12?: string,\n        col13?: string,\n        col14?: string,\n        col15?: string,\n        col16?: string,\n        col17?: string,\n        col18?: string,\n        col19?: string,\n        col20?: string\n    ): void {\n        logData(\n            [col1, col2, col3, col4, col5, col6, col7, col8, col9, col10, col11, col12, col13, col14, col15, col16, col17, col18, col19, col20]\n                .filter(el => !!el)\n                .map(col => createCV(col, \"\"))\n        );\n    }\n\n    /**\n     * Delete all existing logs, including column headers. By default this only marks the log as\n     * overwriteable / deletable in the future.\n     * @param deleteType optional set whether a deletion will be fast or full\n     */\n    //% block=\"slett logg||$deleteType\"\n    //% blockId=dataloggerdeletelog\n    //% group=\"micro:bit (V2)\"\n    //% weight=60 help=datalogger/delete-log\n    export function deleteLog(deleteType?: DeleteType): void {\n        init();\n        flashlog.clear(deleteType === DeleteType.Full);\n        _disabled = false;\n    }\n\n    /**\n     * Register an event to run when no more data can be logged.\n     * @param handler code to run when the log is full and no more data can be stored.\n     */\n    //% block=\"når logg er full\"\n    //% blockId=\"on log full\"\n    //% group=\"micro:bit (V2)\"\n    //% weight=40 help=datalogger/on-log-full\n    export function onLogFull(handler: () => void): void {\n        init();\n        onLogFullHandler = handler;\n    }\n\n    /**\n     * Set the format for timestamps\n     * @param format Format in which to show the timestamp. Setting FlashLogTimeStampFormat.None will disable the timestamp.\n     */\n    //% block=\"sett tidsstempel $format\"\n    //% blockId=dataloggertoggleincludetimestamp\n    //% format.defl=FlashLogTimeStampFormat.None\n    //% group=\"micro:bit (V2)\"\n    //% weight=30 help=datalogger/include-timestamp\n    export function includeTimestamp(format: FlashLogTimeStampFormat): void {\n        init();\n        flashlog.setTimeStamp(format);\n    }\n\n    /**\n     * Set whether data is mirrored to serial or not.\n     * @param on if true, data that is logged will be mirrored to serial\n     */\n    //% block=\"speil data til serial $on\"\n    //% blockId=dataloggertogglemirrortoserial\n    //% on.shadow=toggleOnOff\n    //% on.defl=false\n    //% weight=25 help=datalogger/mirror-to-serial\n    export function mirrorToSerial(on: boolean): void {\n        // TODO:/note intentionally does not have group, as having the same group for all\n        // blocks in a category causes the group to be elided.\n        init();\n        flashlog.setSerialMirroring(on);\n    }\n\n    /**\n     * Number of rows currently used by the datalogger, start counting at fromRowIndex\n     * Treats the header as the first row\n     * @param fromRowIndex 0-based index of start\n     * @returns header + rows\n     */\n    export function getNumberOfRows(fromRowIndex: number = 0): number {\n        return flashlog.getNumberOfRows(fromRowIndex);\n    }\n\n    /**\n     * Get all rows seperated by a newline & each column seperated by a comma.\n     * Starting at the 0-based index fromRowIndex & counting inclusively until nRows.\n     * @param fromRowIndex 0-based index of start\n     * @param nRows inclusive count from fromRowIndex\n     * @returns String where newlines denote rows & commas denote columns\n     */\n    export function getRows(fromRowIndex: number, nRows: number): string {\n        return flashlog.getRows(fromRowIndex, nRows);\n    }\n}"},{"type":"added","filename":"oled-skjerm.ts","value":"// Skriv inn koden din her\n"},{"type":"added","filename":"main.py","value":"def on_forever():\n    pass\nbasic.forever(on_forever)\n"}]},{"timestamp":1769943708361,"editorVersion":"8.0.18","changes":[{"type":"edited","filename":"pxt.json","patch":[{"start1":36,"length1":120,"diffs":[[1,"    \"description\": \"\",\n"]]},{"start1":418,"length1":503,"diffs":[[1,"    \"preferredEditor\": \"tsprj\"\n"]]}]},{"type":"edited","filename":"neo-6m.ts","patch":[{"start1":0,"length1":4723,"diffs":[[1,"// Skriv inn koden din her\n"]]}]},{"type":"edited","filename":"sgp30.ts","patch":[{"start1":0,"length1":2722,"diffs":[[1,"// Skriv inn koden din her\n"]]}]},{"type":"edited","filename":"oled-skjerm.ts","patch":[{"start1":0,"length1":33201,"diffs":[[1,"// Skriv inn koden din her\n"]]}]},{"type":"removed","filename":"main.py","value":"def on_forever():\n    pass\nbasic.forever(on_forever)\n"},{"type":"added","filename":"test.ts","value":"// testene settes inn her; disse vil ikke kompilert så lenge denne pakken blir brukt som en utvidelse.\n"},{"type":"added","filename":"main.blocks","value":"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <block type=\"pxt-on-start\"></block>\n  <block type=\"device_forever\"></block>\n</xml>"}]}],"snapshots":[{"timestamp":1769943127245,"editorVersion":"8.0.18","text":{"main.blocks":"<xml xmlns=\"http://www.w3.org/1999/xhtml\">\n  <block type=\"pxt-on-start\"></block>\n  <block type=\"device_forever\"></block>\n</xml>","main.ts":"\n","README.md":"","pxt.json":"{\n    \"name\": \"CanSat sensorpakke\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"radio\": \"*\",\n        \"microphone\": \"*\"\n    },\n    \"files\": [\n        \"main.blocks\",\n        \"main.ts\",\n        \"README.md\"\n    ],\n    \"additionalFilePaths\": []\n}\n"}}],"shares":[],"lastSaveTime":1769944136235}